# BackendApi

Краткое описание
- `BackendApi` — минимальный Web API на .NET 10. Предоставляет endpoint для расчётов по SKU и возвращает вместе с данными метаданные модели и полезные заголовки ответа.
- Использует EF Core InMemory для хранения и заполнения тестовыми данными (seed) при старте.

Требования
- .NET 10 SDK
- Visual Studio 2026 или `dotnet` CLI

Запуск
1. Откройте решение в Visual Studio 2026 или перейдите в папку проекта и выполните:
2. По умолчанию API будет доступно по `https://localhost:{port}`.

Важные файлы и места расширения
- Модели домена: `BackendApi.Models`
- DTO / выходные типы: `BackendApi.Dtos`
- Контроллер: `BackendApi\Controllers\PlannerController.cs`
- Регистрация EF InMemory и seed: `BackendApi.Extensions` (`AddBackendPersistence()`)

CORS (локальная разработка)
Если фронтенд запускается на `http://localhost:5173`, добавьте в `Program.cs` политику CORS и включите её в pipeline. Пример:

Регистрация персистентности
Убедитесь, что в `Program.cs` вызывается:

Эта расширяющая функция создаёт InMemory БД и добавляет seed-данные.

API — основные конечные точки
- GET `GET /api/planner?selectedSubSkus={value}&selectedSubSkus={value2}`
  - Параметр `selectedSubSkus` — необязательный, множественный (массив строк).
  - Ответ: HTTP 200 с JSON:
    ```json
    {
      "Data": { /* расчётные данные */ },
      "Metadata": { /* описание выходных моделей и рекомендуемых заголовков */ }
    }
    ```
  
Формат метаданных
- `Metadata` содержит описание моделей (имя свойства → тип) и список рекомендуемых заголовков ответа (имя, тип, пример, описание).

Масштабируемость и механизм расчёта

Масштабируемость заключается в переносе логики вычисления сущностей, которые непосредственно не хранятся в базе (amount для SubSku, ContributionGrowth) в классы уровня приложения, расширяя их функционал. Так как все значения высчитываются либо на уровне SubSku как сумма, произведение или частное различных величин, либо на уровне Sku, то в модели Subsku можно ограничить запись полям определённых значений, а высчитывать их на основе переданных из базы данных. Таким образом можно добавлять новые поля и уровни. Это не потребует переписывания кода до тех пор, пока не будут добавлены новые данные в таблицы базы данных. 
